#!/usr/bin/env bash
#
#  This script report top N sqlsession in db with statname.
#
#  Savin
#

###############################################################
#
 #		Variables definition block BEGIN
#
###############################################################

# === Output messages highlight ===
if [ "$TERM" = "dumb" -o "$TERM" = "unknown" ] ; then
        RED=""
        GREEN=""
        BROWN=""
        BLUE=""
        PURPLE=""
        CYAN=""
        WHITE=""
        GRAY=""
        YELLOW=""
        OFF=""
else
        RED="$(tput setaf 1 2>/dev/null)"
        GREEN="$(tput setaf 2 2>/dev/null)"
        BROWN="$(tput setaf 3 2>/dev/null)"
        BLUE="$(tput setaf 4 2>/dev/null)"
        PURPLE="$(tput setaf 5 2>/dev/null)"
        CYAN="$(tput setaf 6 2>/dev/null)"
        WHITE="$(tput setaf 7 2>/dev/null)"
        GRAY="$(tput setaf 8 2>/dev/null)"
        YELLOW="$(tput setaf 11 2>/dev/null)"
        OFF="$(tput sgr0 2>/dev/null)"
fi
# === ===

# === Runtime configuration ===
CONF_FILE="sesstop.conf"; [ -f "$CONF_FILE" ] && { source "$CONF_FILE"
echo "Configuration sourced from ${CONF_FILE}"
cat "$CONF_FILE"
}

TMP_DIR=${TMP_DIR:-"/tmp/sesstat_$$"}
TMP_FILE=${TMP_DIR}"/temp.dat"
SQLITE=${SQLITE:-"/usr/bin/sqlite3"}
SQLITE_DB=${TMP_DIR}"/sesstop_$$.dbf"
DELAY=${DELAY:-20}
[ -z "$TOP_SIZE" ] && TOP_SIZE=$((`tput lines` - 10 ))
v_timestamp=`date +%s`
SCREEN_SIZE_LINES=$((`tput lines` - 1))
original_tty_state=$(stty -g)
# === ===

###############################################################
#
 #		Variables definition block END
#
###############################################################

###############################################################
#
 #		Output functions BEGIN
#
###############################################################
# echo_usage	- output script help
# echo_error	- output error messages
echo_usage() {
	printf "%s\n" "Usage:
`basename $0` [options]
Options:
 -l	--list	[class]		show list of statistics in class
 -f	--find  [name]		find statistic with name
 -i	--id	<stat id>	run top on stat id number with default parameters (10 elements and 20 seconds delay)
 -d --delay [number]    delay information update delay [default 20 sec]
 -t --top-size			display number of top elements [default 10]
 -h     --help                  display this help and exit
Statistics classes:
	1. User
	2. Redo
	3. Enqueue
	4. Cache
	5. OS
	6. Real Application Clusters
	7. SQL
	8. Debug
"
}

echo_error() {
        local exe_name=${EXE_NAME:-$0}
        local str="  ERROR ${exe_name} `date '+%y.%m.%d %H:%M:%S'`: $@"

#        if [ $LOG_LEVEL -le 4 ]
#        then
                printf "%b" "${RED}${str}${OFF}\n" >&2
#                printf "%s\n" "${str}" >> $LOG
#        fi
#        if [ $LOG_LEVEL -eq 5 ]
#        then
#                printf "%s\n" "${str}" >> $LOG
#        fi
}
################################################################
#
 #		Output functions END
#
################################################################
################################################################
#
 #		Supplementary functions BEGIN
#
################################################################
# check_dirs	- check existance of TMP_DIR and create it if needed
# check_sqlite	- check existance and executable of SQLITE binary
# check_command - check result of command and exit on error
# data_purge	- remove sqlite datafile, tempfile and exit
check_dirs () {
	if [ ! -w "${TMP_DIR}" ]
	then
		mkdir -p "${TMP_DIR}"
		check_command $? "Couldn't create temp dir [${TMP_DIR}]"
	fi
}

check_sqlite(){
	if [ ! -x "$SQLITE" ]
	then
		echo_error "$SQLITE not found or did not execute";
		exit 1;
	fi
}

check_command() {
        local exe_name=${EXE_NAME:-$0}
        local cmd_result
        local message
        cmd_result=$?
        shift
        message=$@
        if [ ${cmd_result} -ne 0 ]
        then
                echo_error "$message"
                exit ${cmd_result}
        fi
}

data_purge(){
	[ -f "$TMP_FILE" ] && rm -f ${TMP_FILE}
	[ -f "$SQLITE_DB" ] rm -f ${SQLITE_DB}
	[ -d "$TMP_DIR" ] &&  rm -Rf ${TMP_DIR}
#	echo "Data purge"
	stty ${original_tty_state}
	tput reset
	exit 0
}

progress_bar() {
        wait_time=0
        while [ $wait_time -lt $DELAY ]
        do
                for s in / - \\ \|
                do
                        printf "\r$s"
                        sleep 1
                        ((wait_time++))
                        if [ $wait_time -eq $DELAY ]
                        then
                                break
                        fi
                done
        done
}
###############################################################
#
 #		Supplementary functions END
#
###############################################################
###############################################################
#
 #		Oracle functions BEGIN
#
###############################################################
# oracle_print_stats		- output all stats in database or all stats in database within stat class inputed by parameter
# oracle_find_stat		- find stat name in database which name like 
